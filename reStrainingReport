#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Long;
use FindBin qw($RealBin);
use lib "$RealBin/../lib";

## This program is Copyright (C) 2018-19, Felix Krueger (felix.krueger@babraham.ac.uk)

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program. If not, see <http://www.gnu.org/licenses/>.

my $report_version = 'v0.1.0';
my (@reStrainingOrder_summary_reports);

my ($output_dir,$verbose,$manual_output_file,$candidates) = process_commandline();

# print join (",",@alignment_reports)."\n";
# print join (",",@dedup_reports)."\n";
# print join (",",@splitting_reports)."\n";
# print join (",",@mbias_reports)."\n";
# print join (",",@nuc_reports)."\n";

my %strain_scores;
my %hybrid_scores;
my %allele_ratios;


while (@reStrainingOrder_summary_reports){
	# clearing
  	%strain_scores = ();
  	%hybrid_scores = ();
  	%allele_ratios = ();


  	my $summary_report = shift @reStrainingOrder_summary_reports;

   	### HTML OUTPUT FILE
    	my $report_output = $summary_report;
    	$report_output =~ s/^.*\///; # deleting optional path information
    	$report_output =~ s/\.txt$//;
    	$report_output =~ s/$/.html/;

    	# if -o output_file was specified we are going to use that name preferentially.
    	# This may only happen if there is a single report in the folder, or if a single report has been specified manually
    	if ($manual_output_file){
        	warn "A specific output filename was specified: $manual_output_file. Using that one instead of deriving the filename\n"; sleep(1);
        	$report_output = $manual_output_file;
    	}
    
    	$report_output = $output_dir.$report_output;
    	warn "\nWriting reStrainingOrder HTML report to >> $report_output <<\n\n";
    
    	# Get the report template into a string
    	my $doc = read_report_template('plotly_template.tpl');
    
        $doc =~ s/\{\{report_version\}\}/$report_version/g;
        $doc =~ s/\{\{filename\}\}/$summary_report/g;
    	# Get the plot.ly code into a string. This makes the template so much more managable and also allows for quick replacement of the plot.ly
   	# code itself should it get updated
    	my $plotly_code = read_report_template('plot.ly');
    
    	# replacing the Plot.ly spaceholders with the actual plot.ly code
    	if ($doc =~ s/\{\{plotly_goes_here\}\}.*\{\{plotly_goes_here\}\}/$plotly_code/s){  # treating the string as a single line
      	warn "Plot.ly injection successful!\n" if $verbose;
    	}
    	else{
        	die "Plot.ly incjection not working, won't be able to construct any meaningful HTML reports in this case....\n\n";
   	}

  	#my $reStrainingOrder_logo = read_report_template('reStrainingOrder.logo');
  	#if ($doc =~ s/\{\{rSO_logo_goes_here\}\}.*\{\{rSO_logo_goes_here\}\}/$reStrainingOrder_logo/s){  # treating the string as a single line
  	#	    warn "reStrainingOrder.logo injection successful!\n" if $verbose;
  	#}
  
  	my $bioinf_logo = read_report_template('bioinf.logo');
  	if ($doc =~ s/\{\{bioinf_logo_goes_here\}\}.*\{\{bioinf_logo_goes_here\}\}/$bioinf_logo/s){  # treating the string as a single line
      	warn "bioinf.logo injection successful!\n" if $verbose;
  	}


  	# Create timestamp
  	$doc = getLoggingTime($doc);
  
  	# PROCESSING reStrainingOrder SUMMARY REPORTS
  	warn "="x110,"\n";
  	warn "Using the following reStrainingOrder summary report:\t\t> $summary_report <\n";
  	$doc = read_rSO_summary_report($summary_report,$doc);
  
  
  # SPLITTING REPORT (optional)
  #if ($splitting_report){
  #  warn "Using the following splitting report:\t\t> $splitting_report <\n";
  #  $doc =~ s/\{\{cytosine_methylation_post_deduplication_section\}\}//g; # deleting these tags and then go ahead and fill the table
  #  $doc = read_splitting_report($splitting_report,$doc);
  #}
  #else{
  #  warn "No splitting report file specified, skipping this step\n";
    # deleting the entire Splitting Report C context section from the template
  #  $doc =~ s/\{\{cytosine_methylation_post_deduplication_section\}\}.*\{\{cytosine_methylation_post_deduplication_section\}\}//s; # treating the string as a single line
  #}

  ################################################
  ### PROCESSING SINGLE STRAIN COMPTIBILITY SCORES

 	my $count = 0;
	my $strain_compatibility_content;

  $strain_compatibility_content .= "<tbody>\n";
  $strain_compatibility_content .= "\t<tr>\n";
  $strain_compatibility_content .= "\t\t<th>Strain</th>\n";
  $strain_compatibility_content .= "\t\t<th>Agreeing Calls</th>\n";
  $strain_compatibility_content .= "\t\t<th>Disagreeing Calls</th>\n";
  $strain_compatibility_content .= "\t\t<th>Compatibility Percentage</th>\n";  
  $strain_compatibility_content .= "\t</tr>\n";
  $strain_compatibility_content .= "</tbody>\n";
  $strain_compatibility_content .= "<tbody>\n";

  # warn "\n\nContents of \%strain_scores:\n";
  foreach my $number(sort {$a<=>$b} keys %strain_scores){
    	last if ($count == $candidates);
        $strain_compatibility_content .= "\t<tr>\n";
        $strain_compatibility_content .= "\t\t<td>$strain_scores{$number}->{strain}</td>\n";
        $strain_compatibility_content .= "\t\t<td>$strain_scores{$number}->{agree}</td>\n";
        $strain_compatibility_content .= "\t\t<td>$strain_scores{$number}->{disagree}</td>\n";
        $strain_compatibility_content .= "\t\t<td>$strain_scores{$number}->{percent}</td>\n";
        $strain_compatibility_content .= "\t</tr>\n";      
      	# warn "$number\t$strain_scores{$number}->{strain}\t$strain_scores{$number}->{covered}\t$strain_scores{$number}->{agree}\t$strain_scores{$number}->{disagree}\t$strain_scores{$number}->{percent}\n";
    	++$count;
    } 

    $strain_compatibility_content .= "</tbody>\n";
    # warn "$strain_compatibility_content\n";

    # injecting this into the HTML template
    $doc =~ s/\{\{strain_compatibility_content\}\}/$strain_compatibility_content/g;


    ################################################
    ### PROCESSING SINGLE STRAIN COMPATIBILITY CONFIDENCE
    $count = 0;
  my $strain_compatibility_confidence;

  $strain_compatibility_confidence .= "<tbody>\n";
  $strain_compatibility_confidence .= "\t<tr>\n";
  $strain_compatibility_confidence .= "\t\t<th>Strain</th>\n";
  $strain_compatibility_confidence .= "\t\t<th>Agreeing Calls</th>\n";
  $strain_compatibility_confidence .= "\t\t<th>Compatibility Percentage</th>\n";  
  $strain_compatibility_confidence .= "\t</tr>\n";
  $strain_compatibility_confidence .= "</tbody>\n";
  $strain_compatibility_confidence .= "<tbody>\n";

  # warn "\n\nContents of \%strain_scores:\n";
  foreach my $number(sort {$a<=>$b} keys %strain_scores){
      last if ($count == $candidates);
        $strain_compatibility_confidence .= "\t<tr>\n";
        $strain_compatibility_confidence .= "\t\t<td>$strain_scores{$number}->{strain}</td>\n";
        $strain_compatibility_confidence .= "\t\t<td>$strain_scores{$number}->{agree}</td>\n";
        $strain_compatibility_confidence .= "\t\t<td>$strain_scores{$number}->{percent}</td>\n";
        $strain_compatibility_confidence .= "\t</tr>\n";      
        # warn "$number\t$strain_scores{$number}->{strain}\t$strain_scores{$number}->{covered}\t$strain_scores{$number}->{agree}\t$strain_scores{$number}->{disagree}\t$strain_scores{$number}->{percent}\n";
      ++$count;
    } 

    $strain_compatibility_confidence .= "</tbody>\n";
    # warn "$strain_compatibility_confidence\n";

    # injecting this into the HTML template
    $doc =~ s/\{\{strain_compatibility_confidence\}\}/$strain_compatibility_confidence/g;

    ##########################################
    ### PROCESSING HYBRID COMPATIBILITY SCORES

    my $hybrid_compatibility_content;

    $hybrid_compatibility_content .= "<tbody>\n";
    $hybrid_compatibility_content .= "\t<tr>\n";
    $hybrid_compatibility_content .= "\t\t<th>Potential Hybrid</th>\n";
    $hybrid_compatibility_content .= "\t\t<th>Agreeing Calls</th>\n";
    $hybrid_compatibility_content .= "\t\t<th>Disagreeing Calls</th>\n";
    $hybrid_compatibility_content .= "\t\t<th>Compatibility Percentage</th>\n";  
    $hybrid_compatibility_content .= "\t</tr>\n";
    $hybrid_compatibility_content .= "</tbody>\n";
    $hybrid_compatibility_content .= "<tbody>\n";

  
    $count = 0;
    # warn "\n\nContents of \%hybrid_scores:\n";
    foreach my $number(sort {$a<=>$b} keys %hybrid_scores){
      	last if ($count == $candidates);
        $hybrid_compatibility_content .= "\t<tr>\n";
        $hybrid_compatibility_content .= "\t\t<td>$hybrid_scores{$number}->{hybrid}</td>\n";
        $hybrid_compatibility_content .= "\t\t<td>$hybrid_scores{$number}->{agree}</td>\n";
        $hybrid_compatibility_content .= "\t\t<td>$hybrid_scores{$number}->{disagree}</td>\n";
        $hybrid_compatibility_content .= "\t\t<td>$hybrid_scores{$number}->{percent}</td>\n";
        $hybrid_compatibility_content .= "\t</tr>\n";    
      	# warn "$number\t$hybrid_scores{$number}->{hybrid}\t$hybrid_scores{$number}->{agree}\t$hybrid_scores{$number}->{disagree}\t$hybrid_scores{$number}->{percent}\n";
      	++$count;
    } 

    $hybrid_compatibility_content .= "</tbody>\n";
    # warn "$hybrid_compatibility_content\n";

    # injecting this into the HTML template
    $doc =~ s/\{\{hybrid_compatibility_content\}\}/$hybrid_compatibility_content/g;

  
    ####################################
    ### PROCESSING ALLELE RATIOS SECTION

    my $allelic_ratio_content;

    $allelic_ratio_content .= "<tbody>\n";
    $allelic_ratio_content .= "\t<tr>\n";
    $allelic_ratio_content .= "\t\t<th>Strain1</th>\n";
    $allelic_ratio_content .= "\t\t<th>Strain1 Calls</th>\n";
    $allelic_ratio_content .= "\t\t<th>Strain1 %</th>\n";
    $allelic_ratio_content .= "\t\t<th>Strain2</th>\n";
    $allelic_ratio_content .= "\t\t<th>Strain2 Calls</th>\n";
    $allelic_ratio_content .= "\t\t<th>Strain2 %</th>\n";  
    $allelic_ratio_content .= "\t</tr>\n";
    $allelic_ratio_content .= "</tbody>\n";
    $allelic_ratio_content .= "<tbody>\n";

    $count = 0;
 	  # warn "\n\nContents of \%allele_ratios:\n";
    foreach my $number(sort {$a<=>$b} keys %allele_ratios){
    	   last if ($count == $candidates);
    	   # warn "$number\t$allele_ratios{$number}->{strain1}\t$allele_ratios{$number}->{strain2}\t$allele_ratios{$number}->{strain1_count}\t$allele_ratios{$number}->{strain2_count}\t$allele_ratios{$number}->{strain1_percent}\t$allele_ratios{$number}->{strain2_percent}\n";
    	   ++$count;
          $allelic_ratio_content .= "\t<tr>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain1}</td>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain1_count}</td>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain1_percent}</td>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain2}</td>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain2_count}</td>\n";
          $allelic_ratio_content .= "\t\t<td>$allele_ratios{$number}->{strain2_percent}</td>\n";
          $allelic_ratio_content .= "\t</tr>\n";   
    } 

     $allelic_ratio_content .= "</tbody>\n";
    # warn "$allelic_ratio_content\n";

      # injecting this into the HTML template
     $doc =~ s/\{\{allelic_ratio_content\}\}/$allelic_ratio_content/g;

  	warn "="x110,"\n\n\n";
  	$verbose and sleep(3);

	write_out_report($report_output,$doc);

}

sub write_out_report{
  my ($report_output,$doc) = @_;
  open (OUT,'>',$report_output) or die "Failed to write to output file $report_output: $!\n\n";
  print OUT $doc;
}

sub getLoggingTime {
  my $doc = shift;
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);

  my $time = sprintf ("%02d:%02d:%02d", $hour,$min,$sec);
  my $date = sprintf ("%04d-%02d-%02d", $year+1900,$mon+1,$mday);
  warn "Using Time: $time, and date: $date\n\n" if ($verbose);

  $doc =~ s/\{\{date\}\}/$date/g;
  $doc =~ s/\{\{time\}\}/$time/g;

  return $doc;
}


sub read_rSO_summary_report{

  my ($summary_report,$doc) = @_;

  warn "Processing reStrainingOrder summary report $summary_report ...\n";
  open (SUMM,$summary_report) or die "Couldn't read from file $summary_report: $!\n\n";

  my $unique;
  my $no_aln;
  my $multiple;
  my $no_genomic;
  my $total_seqs;
  my $bismark_version;
  my $input_filename;

  my $unique_text;
  my $no_aln_text;
  my $multiple_text;
  my $total_seq_text;

  my $total_C_count;
  my ($meth_CpG,$meth_CHG,$meth_CHH,$meth_unknown);
  my ($unmeth_CpG,$unmeth_CHG,$unmeth_CHH,$unmeth_unknown);
  my ($perc_CpG,$perc_CHG,$perc_CHH,$perc_unknown);

  my $number_OT;
  my $number_CTOT;
  my $number_CTOB;
  my $number_OB;

  my $processed_strain_scores;
  my $processed_hybrid_scores;
  my $processed_allele_ratios;


  	my $strain_order = 0;
	my $hybrid_order = 0;
	my $allele_ratio_order = 0;

  while (<SUMM>){
    chomp;
   
    unless (defined $processed_strain_scores){
    	# this must the first line
    	if($_ eq 'STRAIN SCORES'){
    		# warn "Fine, this looks like a proper reStrainingOrder summary report\n";
    		++$processed_strain_scores;
    		next;
    	}
    	else{
    		die "This file does not look like a reStrainingOrder summary report. Aborting... (First line was: >$_<\n\n ";
    	}
    }
	# warn "$_\n";

	if ($_ eq ""){
    	# warn "Line is empty: skipping\n\n";
    	next;
    }

    if (defined $processed_hybrid_scores){
    	# warn "Now processing the Hybrid Scores section\n";
    	# this has to be Section 1: Strain Scores
		
		if (defined $processed_allele_ratios){
			# this has to be Section 3: Allele Ratios
			# warn "ALLELE RATIOS: $_\n"; # sleep(1);
			if ($_ =~ /^Strain1/){
    			# warn "Header, skipping...: $_\n"; sleep(1);
   				next; # header
   			}
	   		else{
   				my ($strain1,$strain1_count,$strain1_percent,$strain2,$strain2_count,$strain2_percent) = (split /\t/);
    			++$allele_ratio_order;

    			print join (" // ",$allele_ratio_order,$strain1,$strain2_count,$strain1_percent,$strain2,$strain2_count,$strain2_percent),"\n" if $verbose; # sleep(1);
  	 			$allele_ratios{$allele_ratio_order}->{strain1} = $strain1;
   				$allele_ratios{$allele_ratio_order}->{strain2} = $strain2;
   				$allele_ratios{$allele_ratio_order}->{strain1_count} = $strain1_count;	
	   			$allele_ratios{$allele_ratio_order}->{strain2_count} = $strain2_count;
	   			$allele_ratios{$allele_ratio_order}->{strain1_percent} = $strain1_percent;
	   			$allele_ratios{$allele_ratio_order}->{strain2_percent} = $strain2_percent;	
   			}

		}
		else{
			if ($_ eq 'ALLELE RATIOS'){
	    		# warn "Reached the Allele Ratio section\n";
	    		# sleep(1);
	    		++$processed_allele_ratios;
	    		next;
	   		}
	   		else{
	   			# this has to be Section 2: Hybrid Scores					
    			# warn "HYBRID SCORES: $_\n";
    			
    			if ($_ =~ /^Potential/){
    				# warn "Header, skipping...\n";
   					next; # header
   				}
	   			else{
	   				my ($hybrid,$agree,$disagree,$percent,$strain1_index,$strain2_index) = (split /\t/);
	    			++$hybrid_order;

	    			print join (" // ",$hybrid_order,$hybrid,$agree,$disagree,$percent,$strain1_index,$strain2_index),"\n" if $verbose; # sleep(1);
	  	 			$hybrid_scores{$hybrid_order}->{hybrid} = $hybrid;
	   				$hybrid_scores{$hybrid_order}->{strain1_index} = $strain1_index;
	   				$hybrid_scores{$hybrid_order}->{strain2_index} = $strain2_index;
	   				$hybrid_scores{$hybrid_order}->{agree} = $agree;
	   				$hybrid_scores{$hybrid_order}->{disagree} = $disagree;
	   				$hybrid_scores{$hybrid_order}->{percent} = $percent;
	   			}
	   		}
   		}
   	}
    else{
		# this has to be Section 1: Strain Scores
		if ($_ eq 'HYBRID SCORES'){
    		# warn "Reached the Hybrid Score section\n";
    		++$processed_hybrid_scores;
    		next;
   		}
   		else{
   			# warn "STRAIN SCORES: $_\n";		
   			if ($_ =~ /^Strain/){
   				# warn "Header, skipping...\n";
   				next; # header
   			}
   			else{
   				my ($strain,$covered,$agree,$disagree,$percent) = (split /\t/);
   				++$strain_order;
   				print join (" // ",$strain_order,$strain,$covered,$agree,$disagree,$percent),"\n" if $verbose; # sleep(1);
   				$strain_scores{$strain_order}->{strain} = $strain;
   				$strain_scores{$strain_order}->{covered} = $covered;
   				$strain_scores{$strain_order}->{agree} = $agree;
   				$strain_scores{$strain_order}->{disagree} = $disagree;
   				$strain_scores{$strain_order}->{percent} = $percent;
   			}
   		}
   	}
	
	



    ### General Alignment stats
    if ($_ =~ /^Sequence pairs analysed in total:/ ){                        ## Paired-end
      (undef,$total_seqs) = split /\t/;
      print "Total paired seqs: >> $total_seqs <<\n" if ($verbose);
      $total_seq_text = 'Sequence pairs analysed in total';
    }
    elsif ($_ =~ /^Sequences analysed in total:/ ){                          ## Single-end
      (undef,$total_seqs) = split /\t/;
      $total_seq_text = 'Sequences analysed in total';
      print "total single-end seqs >> $total_seqs <<\n" if ($verbose);
    }

    elsif($_ =~ /^Bismark report for: (.*) \(version: (.*)\)/){
      $input_filename = $1;
      $bismark_version = $2;
      print "Input filename(s) >> $input_filename <<\n" if ($verbose);
      print "Bismark version >> $bismark_version <<\n" if ($verbose);
    }

    elsif($_ =~ /^Number of paired-end alignments with a unique best hit:/){ ## Paired-end
      (undef,$unique) = split /\t/;
      print "Unique PE>> $unique <<\n" if ($verbose);;
      $unique_text = 'Paired-end alignments with a unique best hit';
    }
    elsif($_ =~ /^Number of alignments with a unique best hit from/){        ## Single-end
      (undef,$unique) = split /\t/;
      print "Unique SE>> $unique <<\n" if ($verbose);
      $unique_text = 'Single-end alignments with a unique best hit';
    }

    elsif($_ =~ /^Sequence pairs with no alignments under any condition:/){  ## Paired-end
      (undef,$no_aln) = split /\t/;
      print "No alignment PE >> $no_aln <<\n" if ($verbose);
      $no_aln_text = 'Pairs without alignments under any condition';
    }
    elsif($_ =~ /^Sequences with no alignments under any condition:/){       ## Single-end
      (undef,$no_aln) = split /\t/;
      print "No alignments SE>> $no_aln <<\n" if ($verbose);
      $no_aln_text = 'Sequences without alignments under any condition';
    }

    elsif($_ =~ /^Sequence pairs did not map uniquely:/){                    ## Paired-end
      (undef,$multiple) = split /\t/;
      print "Multiple alignments PE >> $multiple <<\n" if ($verbose);
      $multiple_text = 'Pairs that did not map uniquely';
    }
    elsif($_ =~ /^Sequences did not map uniquely:/){                         ## Single-end
      (undef,$multiple) = split /\t/;
      print "Multiple alignments SE >> $multiple <<\n" if ($verbose);
      $multiple_text = 'Sequences that did not map uniquely';
    }

    elsif($_ =~ /^Sequence pairs which were discarded because genomic sequence could not be extracted:/){ ## Paired-end
      (undef,$no_genomic) = split /\t/;
      print "No genomic sequence PE >> $no_genomic <<\n" if ($verbose);
    }
    elsif($_ =~ /^Sequences which were discarded because genomic sequence could not be extracted:/){ ## Single-end
      (undef,$no_genomic) = split /\t/;
      print "No genomic sequence SE>> $no_genomic <<\n" if ($verbose);
    }

    ### Context Methylation
    elsif($_ =~ /^Total number of C/ ){
      (undef,$total_C_count) = split /\t/;
      print "Total number C >> $total_C_count <<\n" if ($verbose);
    }

      elsif($_ =~ /^Total methylated C\'s in CpG context:/ ){
      (undef,$meth_CpG) = split /\t/;
      print "meth CpG >> $meth_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in CHG context:/ ){
      (undef,$meth_CHG) = split /\t/;
      print "meth CHG >> $meth_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in CHH context:/ ){
      (undef,$meth_CHH) = split /\t/;
      print "meth CHH >> $meth_CHH <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in Unknown context:/ ){
      (undef,$meth_unknown) = split /\t/;
      print "meth Unknown >> $meth_unknown <<\n" if ($verbose);
    }

    elsif($_ =~ /^Total unmethylated C\'s in CpG context:/ or $_ =~ /^Total C to T conversions in CpG context:/){
      (undef,$unmeth_CpG) = split /\t/;
      print "unmeth CpG >> $unmeth_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total unmethylated C\'s in CHG context:/ or $_ =~ /^Total C to T conversions in CHG context:/){
      (undef,$unmeth_CHG) = split /\t/;
      print "unmeth CHG >> $unmeth_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total unmethylated C\'s in CHH context:/ or $_ =~ /^Total C to T conversions in CHH context:/){
      (undef,$unmeth_CHH) = split /\t/;
      print "unmeth CHH >> $unmeth_CHH <<\n"if ($verbose);
    }
    elsif($_ =~ /^Total unmethylated C\'s in Unknown context:/ or $_ =~ /^Total C to T conversions in Unknown context:/){
      (undef,$unmeth_unknown) = split /\t/;
      print "unmeth Unknown >> $unmeth_unknown <<\n" if ($verbose);
    }

    elsif($_ =~ /^C methylated in CpG context:/ ){
      (undef,$perc_CpG) = split /\t/;
      $perc_CpG =~ s/%//;
      print "percentage CpG >> $perc_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in CHG context:/ ){
      (undef,$perc_CHG) = split /\t/;
      $perc_CHG =~ s/%//;
      print "percentage CHG >> $perc_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in CHH context:/ ){
      (undef,$perc_CHH) = split /\t/;
      $perc_CHH =~ s/%//;
      print "percentage CHH >> $perc_CHH <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in Unknown context:/ ){
      (undef,$perc_unknown) = split /\t/;
      $perc_unknown =~ s/%//;
      print "percentage Unknown >> $perc_unknown <<\n" if ($verbose);
    }


    ### Strand Origin

    elsif($_ =~ /^CT\/GA\/CT:/ ){             ## Paired-end
      (undef,$number_OT) = split /\t/;
      print "Number OT PE>> $number_OT <<\n" if ($verbose);
    }
    elsif($_ =~ /^CT\/CT:/ ){                 ## Single-end
      (undef,$number_OT) = split /\t/;
      print "Number OT SE>> $number_OT <<\n" if ($verbose);
    }

    elsif($_ =~ /^GA\/CT\/CT:/ ){             ## Paired-end
      (undef,$number_CTOT) = split /\t/;
      print "Number CTOT PE >> $number_CTOT <<\n" if ($verbose);
    }
    elsif($_ =~ /^GA\/CT:/ ){                 ## Single-end
      (undef,$number_CTOT) = split /\t/;
      print "Number CTOT SE >> $number_CTOT <<\n" if ($verbose);
    }

    elsif($_ =~ /^GA\/CT\/GA:/ ){             ## Paired-end
      (undef,$number_CTOB) = split /\t/;
      print "Number CTOB PE >> $number_CTOB <<\n" if ($verbose);
    }
    elsif($_ =~ /^GA\/GA:/ ){                 ## Single-end
      (undef,$number_CTOB) = split /\t/;
      print "Number CTOB SE >> $number_CTOB <<\n" if ($verbose);
    }

    elsif($_ =~ /^CT\/GA\/GA:/ ){             ## Paired-end
      (undef,$number_OB) = split /\t/;
      print "Number OB PE >> $number_OB <<\n" if ($verbose);
    }
    elsif($_ =~ /^CT\/GA:/ ){                 ## Single-end
      (undef,$number_OB) = split /\t/;
      print "Number OB SE >> $number_OB <<\n" if ($verbose);
    }


  }


  if (defined $unique and defined $no_aln and defined $multiple and defined $no_genomic and defined $total_seqs){
    warn "Got all necessary information, editing HTML report\n"  if ($verbose);

    ### General Alignment Stats
    $doc =~ s/\{\{unique_seqs\}\}/$unique/g;
    $doc =~ s/\{\{unique_seqs_text\}\}/$unique_text/g;

    $doc =~ s/\{\{no_alignments\}\}/$no_aln/g;
    $doc =~ s/\{\{no_alignments_text\}\}/$no_aln_text/g;

    $doc =~ s/\{\{multiple_alignments\}\}/$multiple/g;
    $doc =~ s/\{\{multiple_alignments_text\}\}/$multiple_text/g;

    $doc =~ s/\{\{no_genomic\}\}/$no_genomic/g;

    $doc =~ s/\{\{total_sequences_alignments\}\}/$total_seqs/g;
    $doc =~ s/\{\{sequences_analysed_in_total\}\}/$total_seq_text/g;

    $doc =~ s/\{\{filename\}\}/$input_filename/g;
   

    ### Alignment stats Plot
    $doc =~ s/\{\{alignment_stats_plotly\}\}/$unique,$no_aln,$multiple,$no_genomic/g;

    ### Strand Origin
    $doc =~ s/\{\{number_OT\}\}/$number_OT/g;
    $doc =~ s/\{\{number_CTOT\}\}/$number_CTOT/g;
    $doc =~ s/\{\{number_CTOB\}\}/$number_CTOB/g;
    $doc =~ s/\{\{number_OB\}\}/$number_OB/g;

    ### Context Methylation
    $doc =~ s/\{\{total_C_count\}\}/$total_C_count/g;

    ### Strand Alignment Plot
    $doc =~ s/\{\{strand_alignment_plotly\}\}/$number_OT,$number_CTOT,$number_CTOB,$number_OB/g;

    unless (defined $perc_CpG){
      $perc_CpG = 'N/A';
    }
    unless (defined $perc_CHG){
      $perc_CHG = 'N/A';
    }
    unless (defined $perc_CHH){
      $perc_CHH = 'N/A';
    }
    unless (defined $perc_unknown){
      $perc_unknown = 'N/A';
    }

    ### Unknown sequence context, just for Bowtie 2 alignments
    my $meth_unknown_inject;
    my $unmeth_unknown_inject;
    my $perc_unknown_inject;

    if (defined $meth_unknown){ # if one Unknown context file is present, so should the others
      $meth_unknown_inject = "     <tr>
                                <th>Methylated C's in Unknown context</th>
    				<td>$meth_unknown</td>
    			</tr>";
      $unmeth_unknown_inject = "     <tr>
                                <th>Unmethylated C's in Unknown context</th>
    				<td>$unmeth_unknown</td>
    			</tr>";
      $perc_unknown_inject = "     <tr>
                                <th>Methylated C's in Unknown context</th>
    				<td>$perc_unknown%</td>
    			</tr>";
    }
    else{
      $meth_unknown_inject = $unmeth_unknown_inject = $perc_unknown_inject = '';
    }

    ### injecting this into the table
    $doc =~ s/\{\{meth_unknown\}\}/$meth_unknown_inject/g;
    $doc =~ s/\{\{unmeth_unknown\}\}/$unmeth_unknown_inject/g;
    $doc =~ s/\{\{perc_unknown\}\}/$perc_unknown_inject/g;

    $doc =~ s/\{\{meth_CpG\}\}/$meth_CpG/g;
    $doc =~ s/\{\{meth_CHG\}\}/$meth_CHG/g;
    $doc =~ s/\{\{meth_CHH\}\}/$meth_CHH/g;

    $doc =~ s/\{\{unmeth_CpG\}\}/$unmeth_CpG/g;
    $doc =~ s/\{\{unmeth_CHG\}\}/$unmeth_CHG/g;
    $doc =~ s/\{\{unmeth_CHH\}\}/$unmeth_CHH/g;

    $doc =~ s/\{\{perc_CpG\}\}/$perc_CpG/g;
    $doc =~ s/\{\{perc_CHG\}\}/$perc_CHG/g;
    $doc =~ s/\{\{perc_CHH\}\}/$perc_CHH/g;

    my ($perc_CpG_graph, $perc_CHG_graph,$perc_CHH_graph,$perc_unknown_graph);

    if ($perc_CpG eq 'N/A'){
      $perc_CpG_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CpG_graph =  $perc_CpG;
    }

    if ($perc_CHG eq 'N/A'){
      $perc_CHG_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CHG_graph =  $perc_CHG;
    }

    if ($perc_CHH eq 'N/A'){
      $perc_CHH_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CHH_graph =  $perc_CHH;
    }

    if ($perc_unknown eq 'N/A'){
      $perc_unknown_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_unknown_graph =  $perc_unknown;
    }

    ### Context Methylation Plot
    $doc =~ s/\{\{cytosine_methylation_plotly\}\}/$perc_CpG_graph,$perc_CHG_graph,$perc_CHH_graph/g;
  
  }
  else{
    warn "Am I missing something?\n\n";
  }

  warn "Complete\n\n";
  return $doc;
}


sub read_deduplication_report{

  my ($dedup_report,$doc) = @_;

  warn "Processing deduplication report $dedup_report ...\n";
  open (DEDUP,$dedup_report) or die "Couldn't read from file $dedup_report: $!\n\n";

  my $total_seqs;
  my $dups;
  my $diff_pos;
  my $leftover;

  while (<DEDUP>){
    chomp;
    if ($_ =~ /^Total number of alignments/){
      (undef,$total_seqs) = split /\t/;
      warn "Total number of seqs >> $total_seqs <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total number duplicated/){
      (undef,$dups) = split /\t/;
      $dups =~ s/\s.*//; # just need the number, not the percentage
      warn "Duplicated >> $dups <<\n" if ($verbose);
    }
    elsif($_ =~ /^Duplicated alignments were found at/){
      (undef,$diff_pos) = split /\t/;
      $diff_pos =~ s/\s.*//; # just need the number
      warn "Different positions >> $diff_pos <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total count of deduplicated leftover sequences: (\d+)/){
      $leftover = $1;
      warn "Leftover seqs >> $leftover <<\n" if ($verbose);
    }
  }

  unless (defined $leftover){
    if (defined $dups and defined $total_seqs){
      $leftover = $total_seqs - $dups;
    }
  }

  # Checking if we got all we need
  if (defined $dups and defined $total_seqs and defined $diff_pos and defined $leftover){
    # warn "Got all I need!\n\n";
    $doc =~ s/\{\{seqs_total_duplicates\}\}/$total_seqs/g;
    $doc =~ s/\{\{unique_alignments_duplicates\}\}/$leftover/g;
    $doc =~ s/\{\{duplicate_alignments_duplicates\}\}/$dups/g;
    $doc =~ s/\{\{different_positions_duplicates\}\}/$diff_pos/g;
    
    ### Duplication Plot Plot.ly
    $doc =~ s/\{\{duplication_stats_plotly\}\}/$leftover,$dups/g;
  }
  else{
    warn "Something went wrong... Use --verbose to get a clue...\n";
    # skipping this plot entirely if values could not be extracted
    return $doc;
  }
  warn "Complete\n\n";
  return $doc;
}


sub read_nucleotide_coverage_report{
    
    my ($nuc_report,$doc) = @_;
    
    warn "Processing nucleotide coverage report '$nuc_report' ...\n";
    open (NUC,$nuc_report) or die "Couldn't read from file $nuc_report: $!\n\n";
    
    my %nucs; # storing nucleotides and frequencies
    my $linecount = 0;
    
    while (<NUC>){
	chomp;
	$_ =~ s/\r//; # removing carriage returns
	# warn "$_\n"; sleep(1);
	my ($element,$count_obs,$observed,$count_exp,$expected,$coverage) = (split /\t/);
	# warn "$element , $count_obs , $observed , $count_exp , $expected, $coverage\n"; sleep(1);
	if ($linecount == 0){ # verifying that the data appears to be a Bismark nucleotide coverage report
	    if ($observed eq 'percent sample'){
		# warn "Fine, found '$observed'\n";
	    }
	    else{
		die "Expected to find 'percent sample' as entry in line 1, column 3 but found '$observed'. This doesn't look like a Bismark nucleotide coverage report. Please respecify!\n";
	    }
	    
	    if ($expected eq 'percent genomic'){
		# warn "Fine, found '$expected'\n";
	    }
	    else{
		die "Expected to find 'percent genomic' as entry in line 1, column 5 but found '$expected'. This doesn't look like a Bismark nucleotide coverage report. Please respecify!\n";
	    }
	}
	else{
	    $nucs{$element}->{obs}->{percent}  = $observed;
	    $nucs{$element}->{exp}->{percent}  = $expected;
	    $nucs{$element}->{obs}->{counts}   = $count_obs;
	    $nucs{$element}->{exp}->{counts}   = $count_exp;
	    $nucs{$element}->{obs}->{coverage} = $coverage; # coverage of that nucleotide in the sample
	    warn "Element '$element' observed: $observed\n" if $verbose;
	    warn "Element '$element' expected: $expected\n" if $verbose;
	}

	++$linecount;

    }

    # Checking if we got all we need
    my $looksOK = 1;
    foreach my $key (keys %nucs){
	unless ( (defined $nucs{$key}->{obs}) and (defined $nucs{$key}->{exp})){
	    $looksOK = 0;
	}
    }
    
    if ($looksOK){
	warn "Got all necessary information, editing HTML report ...\n" if $verbose;
	my $minmax = 0;
	my @y_array;
	my @x_genomic;
	my @x_sample;

#	foreach my $key (sort {$a cmp $b} keys %nucs){
	foreach my $key ('A','T','C','G','AC','CA','TC','CT','CC','CG','GC','GG','AG','GA','TG','GT','TT','TA','AT','AA'){
	    my $nuc_obs = $nucs{$key}->{obs}->{percent};
	    my $nuc_exp = $nucs{$key}->{exp}->{percent};
	    my $counts_obs = $nucs{$key}->{obs}->{counts};
	    my $counts_exp = $nucs{$key}->{exp}->{counts};
	    my $cov = $nucs{$key}->{obs}->{coverage};

	    # calculating log2 observed/expected
	    my $ratio = $nuc_obs/$nuc_exp;
	    #  my $logratio = sprintf ("%.2f",log($ratio)/log(2));
	    # if (abs($logratio) > $minmax){
	    # $minmax = abs($logratio);
	    # }
	    warn "$key\tnuc_${key}_obs\t$nuc_obs\tnuc_${key}_exp\t$nuc_exp\tratio: $ratio\n" if $verbose;
	    
	    $doc =~ s/\{\{nuc_${key}_p_obs\}\}/$nuc_obs/g;
	    $doc =~ s/\{\{nuc_${key}_p_exp\}\}/$nuc_exp/g;
	    $doc =~ s/\{\{nuc_${key}_counts_obs\}\}/$counts_obs/g;
	    $doc =~ s/\{\{nuc_${key}_counts_exp\}\}/$counts_exp/g;
	    $doc =~ s/\{\{nuc_${key}_coverage\}\}/$cov/g;

	    # for the plot.ly bargraph
	    push @y_array,   $key;
	    push @x_genomic, $nuc_exp;
	    push @x_sample,  $nuc_obs;
	}

	my $y_array   = join ("','",@y_array);
	my $x_sample  = join (" , ",@x_sample);
	my $x_genomic = join (" , ",@x_genomic);

	$y_array = "'".$y_array."'";

	if ($verbose){
	    print "Y-array: $y_array\n";
	    print "X genomic array: $x_genomic\n";
	    print "X sample array: $x_sample\n";
	}

	$doc =~ s/\{\{nucleo_sample_x\}\}/$x_sample/g;
	$doc =~ s/\{\{nucleo_genomic_x\}\}/$x_genomic/g;
	$doc =~ s/\{\{nucleo_sample_y\}\}/$y_array/g;
	$doc =~ s/\{\{nucleo_genomic_y\}\}/$y_array/g;
	# warn "Minimum/maxium ratio was: $minmax\n" if $verbose;
	# $doc =~ s/\{\{nuc_minmax\}\}/$minmax/g;
    }
    else{
	warn "Something went wrong, skipping this plot entirely... Use --verbose to get a clue...\n";
	# skipping this plot entirely if values could not be extracted
	return $doc;
    }

    warn "Complete\n\n";
    return $doc;
}


sub read_splitting_report{

  my ($splitting_report,$doc) = @_;

  warn "Processing splitting report $splitting_report ...\n";
  open (SPLIT,$splitting_report) or die "Couldn't read from file $splitting_report: $!\n\n";

  my $total_seqs;

  my $total_C_count;
  my ($meth_CpG,$meth_CHG,$meth_CHH,$meth_unknown);
  my ($unmeth_CpG,$unmeth_CHG,$unmeth_CHH,$unmeth_unknown);
  my ($perc_CpG,$perc_CHG,$perc_CHH,$perc_unknown);

  while (<SPLIT>){
    chomp;

    ### Context Methylation
    if($_ =~ /^Total number of C/ ){
      (undef,$total_C_count) = split /\t/;
      print "total calls >> $total_C_count <<\n" if ($verbose);
    }

    elsif($_ =~ /^Total methylated C\'s in CpG context:/ ){
      (undef,$meth_CpG) = split /\t/;
      print "meth CpG >> $meth_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in CHG context:/ ){
      (undef,$meth_CHG) = split /\t/;
      print "meth CHG>> $meth_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in CHH context:/ ){
      (undef,$meth_CHH) = split /\t/;
      print "meth CHH >> $meth_CHH <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total methylated C\'s in Unknown context:/ ){
      (undef,$meth_unknown) = split /\t/;
      print "meth Unknown >> $meth_unknown <<\n" if ($verbose);
    }

    elsif($_ =~ /^Total C to T conversions in CpG context:/ ){
      (undef,$unmeth_CpG) = split /\t/;
      print "unmeth CpG >> $unmeth_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total C to T conversions in CHG context:/ ){
      (undef,$unmeth_CHG) = split /\t/;
      print "unmeth CHG >> $unmeth_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total C to T conversions in CHH context:/ ){
      (undef,$unmeth_CHH) = split /\t/;
      print "unmeth CHH >> $unmeth_CHH <<\n" if ($verbose);
    }
    elsif($_ =~ /^Total C to T conversions in Unknown context:/ ){
      (undef,$unmeth_unknown) = split /\t/;
      print "unmeth Unknown >> $unmeth_unknown <<\n" if ($verbose);
    }

    elsif($_ =~ /^C methylated in CpG context:/ ){
      (undef,$perc_CpG) = split /\t/;
      $perc_CpG =~ s/%//;
      print "percentage CpG >> $perc_CpG <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in CHG context:/ ){
      (undef,$perc_CHG) = split /\t/;
      $perc_CHG =~ s/%//;
      print "percentage CHG >> $perc_CHG <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in CHH context:/ ){
      (undef,$perc_CHH) = split /\t/;
      $perc_CHH =~ s/%//;
      print "percentage CHH >> $perc_CHH <<\n" if ($verbose);
    }
    elsif($_ =~ /^C methylated in Unknown context:/ ){
      (undef,$perc_unknown) = split /\t/;
      $perc_unknown =~ s/%//;
      print "percentage unknown >> $perc_unknown <<\n" if ($verbose);
    }
  }

  if (defined $meth_CpG and defined $meth_CHG and defined $meth_CHH and defined $unmeth_CpG and defined $unmeth_CHG and defined $unmeth_CHH){
    warn "Got all necessary information, editing HTML report ...\n" if ($verbose);

    ### Context Methylation
    $doc =~ s/\{\{total_C_count_splitting\}\}/$total_C_count/g;

    $doc =~ s/\{\{meth_CpG_splitting\}\}/$meth_CpG/g;
    $doc =~ s/\{\{meth_CHG_splitting\}\}/$meth_CHG/g;
    $doc =~ s/\{\{meth_CHH_splitting\}\}/$meth_CHH/g;

    $doc =~ s/\{\{unmeth_CpG_splitting\}\}/$unmeth_CpG/g;
    $doc =~ s/\{\{unmeth_CHG_splitting\}\}/$unmeth_CHG/g;
    $doc =~ s/\{\{unmeth_CHH_splitting\}\}/$unmeth_CHH/g;

    unless (defined $perc_CpG){
      $perc_CpG = 'N/A';
    }
    unless (defined $perc_CHG){
      $perc_CHG = 'N/A';
    }
    unless (defined $perc_CHH){
      $perc_CHH = 'N/A';
    }
    unless (defined $perc_unknown){
      $perc_unknown = 'N/A';
    }

    ### Unknown sequence context, just for Bowtie 2 alignments
    my $meth_unknown_inject;
    my $unmeth_unknown_inject;
    my $perc_unknown_inject;

    if (defined $meth_unknown){ # if one Unknown context file is present, so should the others
      $meth_unknown_inject = "     <tr>
                                <th>Methylated C's in Unknown context</th>
    				<td>$meth_unknown</td>
    			</tr>";
      $unmeth_unknown_inject = "     <tr>
                                <th>Unmethylated C's in Unknown context</th>
    				<td>$unmeth_unknown</td>
    			</tr>";
      $perc_unknown_inject = "     <tr>
                                <th>Methylated C's in Unknown context</th>
    				<td>$perc_unknown%</td>
    			</tr>";
    }
    else{
      $meth_unknown_inject = $unmeth_unknown_inject = $perc_unknown_inject = '';
    }

    ### injecting this into the table
    $doc =~ s/\{\{meth_unknown_splitting\}\}/$meth_unknown_inject/g;
    $doc =~ s/\{\{unmeth_unknown_splitting\}\}/$unmeth_unknown_inject/g;
    $doc =~ s/\{\{perc_unknown_splitting\}\}/$perc_unknown_inject/g;

    # for the graph we need to take care that there are no N/A values in the percentage fields
    my ($perc_CpG_graph, $perc_CHG_graph,$perc_CHH_graph,$perc_unknown_graph);

    if ($perc_CpG eq 'N/A'){
      $perc_CpG_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CpG_graph =  $perc_CpG;
    }

    if ($perc_CHG eq 'N/A'){
      $perc_CHG_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CHG_graph =  $perc_CHG;
    }

    if ($perc_CHH eq 'N/A'){
      $perc_CHH_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_CHH_graph =  $perc_CHH;
    }

    if ($perc_unknown eq 'N/A'){
      $perc_unknown_graph = 0; # values of 0 won't show in the graph and won't produce errors
    }
    else{
      $perc_unknown_graph =  $perc_unknown;
    }

    # Context Methylation post Duplication Graph
    $doc =~ s/\{\{cytosine_methylation_post_duplication_plotly\}\}/$perc_CpG_graph,$perc_CHG_graph,$perc_CHH_graph/g;

    # Table
    $doc =~ s/\{\{perc_CpG_splitting\}\}/$perc_CpG/g;
    $doc =~ s/\{\{perc_CHG_splitting\}\}/$perc_CHG/g;
    $doc =~ s/\{\{perc_CHH_splitting\}\}/$perc_CHH/g;
  }
  else{
    warn "Am I missing something? Try using --verbose to get a clue...\n\n";
  }
  warn "Complete\n\n";

  return $doc;

}


sub read_mbias_report{

  my ($mbias_report,$doc) = @_;

  warn "Processing M-bias report $mbias_report ...\n";
  open (MBIAS,$mbias_report) or die "Couldn't read from file $mbias_report: $!\n\n";

  my %mbias_1;
  my %mbias_2;

  my $context;
  my $read_identity;
  my $state = 'single'; # setting this to 'single' if there is no read 2

  while (<MBIAS>){
      chomp;
      if ($_ =~ /^(C.{2}) context/){
        $context = $1;

          if ($_ =~ /R2/){
	           $read_identity = 2;
	           $state = 'paired';
          }
          else{
	         $read_identity = 1;
          }

      # warn "new context is: $context\n";
      # warn "Read identity is: Read $read_identity\n";
      }
      if ($_ =~ /^\d/){
          my ($pos,$meth,$unmeth,$perc,$coverage) = (split /\t/);
          if ($read_identity == 1){ 
              push @{$mbias_1{$context}->{coverage_x}}, $pos;
              push @{$mbias_1{$context}->{coverage_y}}, $coverage;
              push @{$mbias_1{$context}->{perc_x}}, $pos; 
              push @{$mbias_1{$context}->{perc_y}}, $perc;  
	  }
	  elsif ($read_identity == 2){
	      push @{$mbias_2{$context}->{coverage_x}}, $pos;
	      push @{$mbias_2{$context}->{coverage_y}}, $coverage;
	      push @{$mbias_2{$context}->{perc_x}}, $pos;
	      push @{$mbias_2{$context}->{perc_y}}, $perc;
	  }
	  else{
	      warn "read identity was unknown : '$read_identity'\n\n";
	  }

      # print join (" ",$pos,$meth,$unmeth,$perc,$coverage)."\n";
    }
  }

  # Read 1 M-bias
  my $r1_CpG_coverage_x = join (',',@{$mbias_1{'CpG'}->{coverage_x}});
  my $r1_CpG_coverage_y = join (',',@{$mbias_1{'CpG'}->{coverage_y}}); 
  my $r1_CpG_perc_x     = join (',',@{$mbias_1{'CpG'}->{perc_x}});
  my $r1_CpG_perc_y     = join (',',@{$mbias_1{'CpG'}->{perc_y}});

  my $r1_CHG_coverage_x = join (',',@{$mbias_1{'CHG'}->{coverage_x}});
  my $r1_CHG_coverage_y = join (',',@{$mbias_1{'CHG'}->{coverage_y}}); 
  my $r1_CHG_perc_x     = join (',',@{$mbias_1{'CHG'}->{perc_x}});
  my $r1_CHG_perc_y     = join (',',@{$mbias_1{'CHG'}->{perc_y}});

  my $r1_CHH_coverage_x = join (',',@{$mbias_1{'CHH'}->{coverage_x}});
  my $r1_CHH_coverage_y = join (',',@{$mbias_1{'CHH'}->{coverage_y}}); 
  my $r1_CHH_perc_x     = join (',',@{$mbias_1{'CHH'}->{perc_x}});
  my $r1_CHH_perc_y     = join (',',@{$mbias_1{'CHH'}->{perc_y}});

  # warn "R1 CpG coverage:\n$r1_CpG_coverage_x\n$r1_CpG_coverage_y\nR1 CpG methylation:\n$r1_CpG_perc_x\n$r1_CpG_perc_y\n\n";
  # warn "R1 CHG coverage:\n$r1_CHG_coverage_x\n$r1_CHG_coverage_y\nR1 CHG methylation:\n$r1_CHG_perc_x\n$r1_CHG_perc_y\n\n";
  # warn "R1 CHH coverage:\n$r1_CHH_coverage_x\n$r1_CHH_coverage_y\nR1 CHH methylation:\n$r1_CHH_perc_x\n$r1_CHH_perc_y\n\n";
  
  # CpG
  $doc =~ s/\{\{mbias1_CpG_meth_x\}\}/$r1_CpG_perc_x/g;
  $doc =~ s/\{\{mbias1_CpG_meth_y\}\}/$r1_CpG_perc_y/g; 
  $doc =~ s/\{\{mbias1_CpG_coverage_x\}\}/$r1_CpG_coverage_x/g;
  $doc =~ s/\{\{mbias1_CpG_coverage_y\}\}/$r1_CpG_coverage_y/g; 
  # CHG 
  $doc =~ s/\{\{mbias1_CHG_meth_x\}\}/$r1_CHG_perc_x/g;
  $doc =~ s/\{\{mbias1_CHG_meth_y\}\}/$r1_CHG_perc_y/g; 
  $doc =~ s/\{\{mbias1_CHG_coverage_x\}\}/$r1_CHG_coverage_x/g;
  $doc =~ s/\{\{mbias1_CHG_coverage_y\}\}/$r1_CHG_coverage_y/g; 
  # CHH
  $doc =~ s/\{\{mbias1_CHH_meth_x\}\}/$r1_CHH_perc_x/g;
  $doc =~ s/\{\{mbias1_CHH_meth_y\}\}/$r1_CHH_perc_y/g; 
  $doc =~ s/\{\{mbias1_CHH_coverage_x\}\}/$r1_CHH_coverage_x/g;
  $doc =~ s/\{\{mbias1_CHH_coverage_y\}\}/$r1_CHH_coverage_y/g; 

  # Read 2 M-bias
  if (%mbias_2){
    my $r2_CpG_coverage_x = join (',',@{$mbias_2{'CpG'}->{coverage_x}});
    my $r2_CpG_coverage_y = join (',',@{$mbias_2{'CpG'}->{coverage_y}}); 
    my $r2_CpG_perc_x     = join (',',@{$mbias_2{'CpG'}->{perc_x}});
    my $r2_CpG_perc_y     = join (',',@{$mbias_2{'CpG'}->{perc_y}});

    my $r2_CHG_coverage_x = join (',',@{$mbias_2{'CHG'}->{coverage_x}});
    my $r2_CHG_coverage_y = join (',',@{$mbias_2{'CHG'}->{coverage_y}}); 
    my $r2_CHG_perc_x     = join (',',@{$mbias_2{'CHG'}->{perc_x}});
    my $r2_CHG_perc_y     = join (',',@{$mbias_2{'CHG'}->{perc_y}});

    my $r2_CHH_coverage_x = join (',',@{$mbias_2{'CHH'}->{coverage_x}});
    my $r2_CHH_coverage_y = join (',',@{$mbias_2{'CHH'}->{coverage_y}}); 
    my $r2_CHH_perc_x     = join (',',@{$mbias_2{'CHH'}->{perc_x}});
    my $r2_CHH_perc_y     = join (',',@{$mbias_2{'CHH'}->{perc_y}});

    # warn "r2 CpG coverage:\n$r2_CpG_coverage_x\n$r2_CpG_coverage_y\nr2 CpG methylation:\n$r2_CpG_perc_x\n$r2_CpG_perc_y\n\n";
    # warn "r2 CHG coverage:\n$r2_CHG_coverage_x\n$r2_CHG_coverage_y\nr2 CHG methylation:\n$r2_CHG_perc_x\n$r2_CHG_perc_y\n\n";
    # warn "r2 CHH coverage:\n$r2_CHH_coverage_x\n$r2_CHH_coverage_y\nr2 CHH methylation:\n$r2_CHH_perc_x\n$r2_CHH_perc_y\n\n";
    
    # CpG
    $doc =~ s/\{\{mbias2_CpG_meth_x\}\}/$r2_CpG_perc_x/g;
    $doc =~ s/\{\{mbias2_CpG_meth_y\}\}/$r2_CpG_perc_y/g; 
    $doc =~ s/\{\{mbias2_CpG_coverage_x\}\}/$r2_CpG_coverage_x/g;
    $doc =~ s/\{\{mbias2_CpG_coverage_y\}\}/$r2_CpG_coverage_y/g; 
    # CHG 
    $doc =~ s/\{\{mbias2_CHG_meth_x\}\}/$r2_CHG_perc_x/g;
    $doc =~ s/\{\{mbias2_CHG_meth_y\}\}/$r2_CHG_perc_y/g; 
    $doc =~ s/\{\{mbias2_CHG_coverage_x\}\}/$r2_CHG_coverage_x/g;
    $doc =~ s/\{\{mbias2_CHG_coverage_y\}\}/$r2_CHG_coverage_y/g; 
    # CHH
    $doc =~ s/\{\{mbias2_CHH_meth_x\}\}/$r2_CHH_perc_x/g;
    $doc =~ s/\{\{mbias2_CHH_meth_y\}\}/$r2_CHH_perc_y/g; 
    $doc =~ s/\{\{mbias2_CHH_coverage_x\}\}/$r2_CHH_coverage_x/g;
    $doc =~ s/\{\{mbias2_CHH_coverage_y\}\}/$r2_CHH_coverage_y/g; 


  }
  else {
      $doc =~ s/\{\{bm_mbias_2\}\}/false/g;
  }
  warn "Complete\n\n";

  return ($state,$doc);

}


sub read_report_template{
    my $template = shift;
    my $doc;
    warn "Attempting to open file from: $RealBin/plotly/$template\n\n" if ($verbose);
    open (DOC,"$RealBin/plotly/$template") or die "Failed to find file $template: $!";
    while(<DOC>){
		chomp;
		$_ =~ s/\r//g;
		$doc .= $_."\n";
    }
    
    close DOC or warn $!;
    return $doc;
}



sub process_commandline{
	my $help;
	my $output_dir;
	my $manual_output_file;
	my $summary_report;
	my $candidates;
	my $verbose;

	my $version;
	
	my $command_line = GetOptions ('help|man'              => \$help,
				 'dir=s'                 => \$output_dir,
				 'o|output=s'            => \$manual_output_file,
				 'summary_report=s'      => \$summary_report,
				 'version'               => \$version,
				 'candidates=i'          => \$candidates,
				 'verbose'               => \$verbose,
				);

	### EXIT ON ERROR if there were errors with any of the supplied options
	unless ($command_line){
		die "Please re-specify command line options\n";
	}

	### HELPFILE
	if ($help){
		print_helpfile();
		exit;
	}

	if ($version){
		print << "VERSION";

                              reStrainingOrder HTML Report Module
                                    version: $report_version

                     Copyright 2018-19 Felix Krueger, Babraham Bioinformatics
                            https://github.com/FelixKrueger/Bismark
	
VERSION
		exit;
	}

	### OUTPUT DIR PATH
	if (defined $output_dir){
		unless ($output_dir eq ''){ # if the output dir has been passed on by the methylation extractor and is an empty string we don't want to change it
			unless ($output_dir =~ /\/$/){
				$output_dir =~ s/$/\//;
			}
		}
	}
	else{
		$output_dir = '';
	}	


	## First we are looking for alignment reports, and then look whether there are any optional plots with the same base name

	if ($summary_report){
		### we only process the one alignment report (and possibly the other ones as well) that was specified
		push @reStrainingOrder_summary_reports, $summary_report;
	}
	else{ ### no alignment report specified, looking in the current directory for files ending in *E_report.txt (SE or PE)

		### looking in the current directory for report files. Less than 1 report file is not allowed
		@reStrainingOrder_summary_reports = <*reStrainingOrder.summary_stats.txt>;

		if (scalar @reStrainingOrder_summary_reports == 0){
			warn "Found no potential reStrainingOrder summary reports in the current directory. Please specify a single reStrainingOrder summary report file using the option '--summary_report FILE'\n\n";
			print_helpfile();
			exit;
		}
		else{
			# there are reStrainingOrder summary report(s) in the directory
			warn "Found ",scalar @reStrainingOrder_summary_reports," summary reports in current directory. Now processing all of them.\n";
		}
	}

	### Ensuring that there isn't more than 1 file in @reStrainingOrder_summary_reports if someone manually specified an output file.
	if (scalar @reStrainingOrder_summary_reports > 1){
		if (defined $manual_output_file){
			die "You cannot run reStrainingReport on more than 1 file while specifying a single output file. Either lose the option -o to derive the output filenames automatically, or specify a single reStrainingOrder summary report file using the option '--summary_report FILE'\n\n";
		}
	}

	if (defined $candidates){
		unless ($candidates > 0 and $candidates <= 30){
			die "Please select a number of candidates between 1 and 30 (the default is 10) and try again\n";
		}
		warn "Reporting >>$candidates<< potential hybrid combinations [user defined]\n";
	}
	else{
		# the default number of candidates is 10
		$candidates = 10;
		warn "Reporting >>$candidates<< potential hybrid combinations [default]\n";
	}
	return ($output_dir,$verbose,$manual_output_file,$candidates);

}

sub print_helpfile{
  print <<EOF

  SYNOPSIS:

  This script uses a Bismark alignment report to generate a graphical HTML report page. Optionally, further reports of
  the Bismark suite such as deduplication, methylation extractor splitting or M-bias reports can be specified as well. If several
  Bismark reports are found in the same folder, a separate report will be generated for each of these, whereby the output filename
  will be derived from the Bismark alignment report file. bismark2report attempts to find optional reports automatically based
  on the file basename.


  USAGE: bismark2report [options]


-o/--output <filename>     Name of the output file (optional). If not specified explicitly, the output filename will be derived
                           from the Bismark alignment report file. Specifying an output filename only works if the HTML report is
                           to be generated for a single Bismark alignment report (and potentially additional reports).

--dir                      Output directory. Output is written to the current directory if not specified explicitly.


--alignment_report FILE    If not specified explicitly, bismark2report attempts to find Bismark report file(s) in the current
                           directory and produces a separate HTML report for each mapping report file. Based on the basename of
                           the Bismark mapping report, bismark2report will also attempt to find the other Bismark reports (see below)
                           for inclusion into the HTML report. Specifying a Bismark alignment report file is mandatory.


                           Script last modified: 21 July 2019

EOF
    ;
  exit 1;
}

